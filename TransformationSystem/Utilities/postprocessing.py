#!/usr/bin/env python

import subprocess
from os import listdir
from os.path import isfile, join
from re import match
import sys
import argparse
import postprocessor
import ROOT
import yaml

# Postprocessing:
# Concatenate files generated by the processing and generate quality plots.
# This does not check for duplicate input files.
# Usage: python postprocessing.py data_quality -i events_rif_000001097.root
# N. Buzinsky & M. Guigue

##############################################################################################################
# This script generates the post-processing plots. It is meant to be general enough to easily include most use cases within a few lines of code.
#
# The following examples functions are used to create the general plots:
#    plot a histogram of fStartFrequency, with all (default) options listed
#    plotter.DrawHistogram1D("fStartFrequency", xTitle = "Start Frequency [Hz]", nBins = 100, xRange = None, logy = False, fit = None)
#    Note xRange is auto-set, unless you choose something explicit. See the fitting section on an example of a fit.

#    plotter.DrawHistogram1D(["fStartFrequency","fTracks.StartFrequency"], "Start Frequency [Hz]")
#    When using the DrawHistogram1D function, if you use a list for the variable names, it will loop over variables, plot them in same graph. Have to be on same scale

#    Plots 2D Histogram fTimeLength, vs. fStartFrequency. For 2D hists. you cannot plot multiple on same graph or fit
#    plotter.DrawHistogram2D('fTimeLength','fStartFrequency',"Time Length [s]", "Start Frequency [Hz]")

#   Custom plots:
#   If you have a plot that uses a variable not directly in the ROOT Trees, you can use the function
#   fVariableList = plot.GetVariable(fVariable)
#   to get a python list of a tree variable. You can then do any custom function of this leaf (or multiple leaves) and put it into a new list: fOutputList
#   Using the following function, you can set your custom list to a new variable name. From their, this new variable can be used above identically as any tree variable.
#   plotter.SetVariable("fOutputVariable",fOutputList)  ### See Custom Plots

#   Refer to postprocessor.py for the function definitions/ arguments
##############################################################################################################


def data_quality(input_file, tree_name, notify_slack, output=None, force=None):
    plotter = postprocessor.plotter(input_file, tree_name, output)

    ########Generic Plots#############
    plotter.DrawHistogram1D("fStartTimeInAcq", "StartTimeinAcq [s]")
    plotter.DrawHistogram1D(
        "fStartFrequency", "Start Frequency [Hz]", statsBoxStyle="emr")
    plotter.DrawHistogram1D("fTracks.fTotalTrackNUP",
                            "Tracks Total NU Power []", logy=True)
    plotter.DrawHistogram1D("fTracks.fMaxTrackNUP",
                            "Tracks Max NU Power []", logy=True)
    plotter.DrawHistogram1D(
        "fFirstTrackTimeLength", "First Track Time Length [s]", nBins=50, logy=True, xRange=[0, 0.002048])

    plotter.DrawHistogram1D(
        ["fTracks.fSlope", "fFirstTrackSlope"], "Slope [Hz/s]")

    plotter.DrawHistogram2D('fTimeLength', 'fStartFrequency',
                            "Time Length [s]", "Start Frequency [Hz]")
    plotter.DrawHistogram2D('fTimeLength', 'fStartTimeInAcq',
                            "Time Length [s]", "StartTimeInAcq [s]")
    plotter.DrawHistogram2D('fTracks.fSlope', 'fTracks.fStartFrequency',
                            "Track Slope [Hz/s]", "Track Start Frequency [Hz]")
    plotter.DrawHistogram2D('fTracks.fSlope', 'fTracks.fTotalPower',
                            "Track Slope [Hz/s]", "Track Total Power [W]")

    # Custom Plots############# # 1D/2D Histograms involving custom mathematical expressions of tree variables

    # Define Track power (ie track spectral power / track time length) with anonymous function (no hanging local variables)
    # Breakdown: plotter.GetVariable("fVariable") returns python list of fVariable read from tree.
    # The map, lambda functions are a terse way to provide a list which is element wise TrackPower/ TrackTimeLength. You could do this with a loop if you wanted
    trackNUPowerDensityBins = list(map(lambda x, y: x / y, plotter.GetVariable(
        "fFirstTrackTotalNUP"), plotter.GetVariable("fFirstTrackNTrackBins")))
    trackNUPowerDensityTime = list(map(lambda x, y: x / y, plotter.GetVariable(
        "fFirstTrackTotalNUP"), plotter.GetVariable("fFirstTrackTimeLength")))

    # Once the custom list is defined, set the variable. It can be plotted using the existing framework, as any other tree variable
    plotter.SetVariable("fFirstTrackNUPowerDensityBins",
                        trackNUPowerDensityBins)
    plotter.SetVariable("fFirstTrackNUPowerDensityTime",
                        trackNUPowerDensityTime)

    plotter.DrawHistogram1D(
        "fFirstTrackNUPowerDensityBins", "NU Power Bins Density []")

    plotter.DrawHistogram2D("fStartFrequency", "fFirstTrackNUPowerDensityBins",
                            "Start Frequency [Hz]", "First Track NU Power Bins Density []")
    plotter.DrawHistogram2D("fStartFrequency", "fFirstTrackNUPowerDensityTime",
                            "Start Frequency [Hz]", "First Track NU Power Time Density [1/s]")

    # Time/ frequency "jumps" between events/ tracks. This is more complicated than normal plotting 
    #(need to retain event/ track structure). Do manually
    start_freqs = []
    end_freqs = []
    start_times = []
    end_times = []

    jump_times = []
    jump_freqs = []
    track_jump_times = []
    track_jump_freqs = []

    #for iEntry in range(plotter.tree.GetEntries()):
    start_freqs = plotter.GetStructuredArray("fTracks.fStartFrequency")
    end_freqs = plotter.GetStructuredArray("fTracks.fEndFrequency")
    start_times = plotter.GetStructuredArray("fTracks.fStartTimeInRunC")
    end_times = plotter.GetStructuredArray("fTracks.fEndTimeInRunC")

    #First index is event number, second is track number (-1 is last)
    for i in range(0,len(start_freqs)):
        for j in range(1,len(start_freqs[i])):
            track_jump_times.append(start_times[i][j] - end_times[i][j-1])
            track_jump_freqs.append(start_freqs[i][j] - end_freqs[i][j-1])


    for i in range(1,len(start_freqs)):
        jump_times.append(start_times[i][0] - end_times[i-1][-1])
        jump_freqs.append(start_freqs[i][0] - end_freqs[i-1][-1])

    plotter.SetVariable("fTrackTimeJump", track_jump_times)
    plotter.SetVariable("fTrackFrequencyJump", track_jump_freqs)
    plotter.SetVariable("fTimeJump", jump_times)
    plotter.SetVariable("fFrequencyJump", jump_freqs)

    plotter.DrawHistogram1D("fTrackTimeJump", "Jump Time Between Tracks [s]")
    plotter.DrawHistogram1D("fTrackFrequencyJump", "Jump Freq Between Tracks [Hz]", xRange=[-25e6,25e6])
    plotter.DrawHistogram1D("fTimeJump", "Jump Time Between Events [s]", xRange=[-0.1,2], logy=True)
    plotter.DrawHistogram1D("fFrequencyJump", "Jump Freq Between Events [Hz]")

    #######################################################
    track_times = plotter.GetStructuredArray("fTracks.fTimeLength")
    event_times = plotter.GetVariable("fTimeLength")
    track_times_summed = [sum(ev) for ev in track_times]
    missing_time =  [ai-bi for ai, bi in zip(event_times,track_times_summed)]

    plotter.SetVariable("fSummedTrackTimeLength", track_times_summed)
    plotter.SetVariable("fMissingTimeLength", missing_time)
    plotter.DrawHistogram1D("fSummedTrackTimeLength", "Summed Track Time Length (s)", nBins=50, logy=True, xRange=[0, 0.002048])
    plotter.DrawHistogram1D("fMissingTimeLength", "Missing Time Length(s)", logy=True)
    plotter.DrawHistogram2D('fTimeLength', 'fMissingTimeLength', "Time Length [s]", "Missing Time Length [s]")
    #######################################################


    ####### Plot/ fit number of tracks per event #######
    # Requires special number of bins (as it is integer)
    nTracksMax = int(max(plotter.GetVariable("fTotalEventSequences")))

    hNTracks = plotter.MakeHist1D(
        "fTotalEventSequences", nBins=nTracksMax, xRange=[0.5, nTracksMax+0.5])

    # Define Fit function
    # Parameter names/ values will show up on quality plot!
    fit_NTracks = ROOT.TF1(
        "Exp. Fit", "[0]*exp((x-1)*log([1]))*(1.-[1])", 0.5, nTracksMax+0.5)
    fit_NTracks.SetParLimits(0, 10, 5e4)
    fit_NTracks.SetParLimits(1, 0.001, 1.)
    fit_NTracks.SetParName(0, "Amplitude")
    fit_NTracks.SetParName(1, "Survival Prob.")
    hNTracks.Fit("Exp. Fit", "MLER")
    fit_NTracks.SetLineColor(4)
    # If using custom fit, MakeHist1D: delete to avoid memory leaks!
    del hNTracks

    plotter.DrawHistogram1D(["fTotalEventSequences"], "Number of Tracks per Event []",
                            nBins=nTracksMax, xRange=[0.5, nTracksMax+0.5], logy=True, fit=[fit_NTracks])

    #########################################################

    # Plot Event Time Lengths/ First Track Lengths on same plot/ fit
    maxTrackLength = max(plotter.GetVariable("fTimeLength"))
    
    hEventLength = plotter.MakeHist1D("fTimeLength")
    fitEventLength = ROOT.TF1(
        "First Track Exp. Fit", "[0]* 0.5*TMath::Erfc([2]- sqrt(1.1e-15 * 0.5 / (1.38e-23 * [3]) *x)) * exp(-1000.*x/[1])*1000/[1]", 1e-4, maxTrackLength)
    fitEventLength.SetParLimits(1, 1e-5, 1e4)
    fitEventLength.SetParLimits(2, 5, 8)
    fitEventLength.SetParLimits(3, 10, 1e3)
    fitEventLength.SetParName(0, "Amplitude")
    fitEventLength.SetParName(1, "Time cst. [ms]")
    fitEventLength.SetParName(2, "ErfcInvPFA")
    fitEventLength.SetParName(3, "Eff. Temp. [K]")
    hEventLength.Fit("First Track Exp. Fit", "MLER")
    fitEventLength.SetLineColor(1)
    del hEventLength

    hFirstTrackLength = plotter.MakeHist1D("fFirstTrackTimeLength")
    fitTrackLength = ROOT.TF1(
        "First Track Exp. Fit", "[0]* 0.5*TMath::Erfc([2]- sqrt(1.1e-15 * 0.5 / (1.38e-23 * [3]) *x)) * exp(-1000.*x/[1])*1000/[1]", 1e-4, maxTrackLength)
    fitTrackLength.SetParLimits(1, 1e-5, 1e4)
    fitTrackLength.SetParLimits(2, 5, 8)
    fitTrackLength.SetParLimits(3, 10, 1e3)
    fitTrackLength.SetParName(0, "Amplitude")
    fitTrackLength.SetParName(1, "Time cst. [ms]")
    fitTrackLength.SetParName(2, "ErfcInvPFA")
    fitTrackLength.SetParName(3, "Eff. Temp. [K]")
    hFirstTrackLength.Fit("First Track Exp. Fit", "MLER")
    fitTrackLength.SetLineColor(2)
    del hFirstTrackLength

    plotter.DrawHistogram1D(["fTimeLength", "fFirstTrackTimeLength","fMissingTimeLength"],
                            "Time Length [s]", logy=True, fit=[fitEventLength, fitTrackLength])
    #print('Reaching slack notification')
    #print(notify_slack)
    #if notify_slack:
    #print('Notifying on slack.')
    plotter.notify_slack()



def trigger_mask(input_file, output=None, force=False):
    plotter = postprocessor.plotter(input_file)
    mask_dict = yaml.load(open(input_file[0]))
    mask1 = mask_dict["mask"]
    mask2 = mask_dict["mask2"]
    x = range(len(mask1))
    plotter.SetVariable("fMask1", mask1)
    plotter.SetVariable("fMask2", mask2)
    plotter.SetVariable("xGraph", x)
    plotter.DrawGraph(["xGraph","xGraph"],["fMask1","fMask2"], xTitle="Frequency Bin", yTitle="Power [A.U.]")


def concat_root_rid(output, rid, katydid, input_folder, force=False):
    if '-' in rid:
        min_rid = int(rid.split('-')[0])
        max_rid = int(rid.split('-')[1])+1
        rid_list = [a_rid for a_rid in range(min_rid, max_rid)]
    else:
        rid_list = [int(rid)]
    for a_rid in rid_list:
        fullrid = "rid%09d" % (a_rid)
        onlyfiles = [join(input_folder, f) for f in listdir(
            input_folder) if isfile(join(input_folder, f)) and fullrid in f and "event.root" in f]
        print('postprocessing: number of files to concat: {}'.format(len(onlyfiles)))
        if output == '.' or not output.endswith(".root"):
            outputfile = join(output,"events_{}_katydid_{}_concat.root".format(
                fullrid, katydid))
        else:
            outputfile = output
        concat_root(outputfile, onlyfiles, force)


def concat_root(output, input_root_files, force=False):
    '''
    Concatenate the root files into one single root file.
    Doing so will merge the trees of each input file.
    '''
    # Finding hadd and adding force
    command = 'hadd'
    if force:
        print('postprocessing: Forcing operation')
        command = '{} -f'.format(command)
    print('postprocessing: command = {}'.format(command))

    command = '{} {}'.format(command, output)
    print('postprocessing: output = {}'.format(output))
    if isinstance(input_root_files, str):
        input_root_files = [input_root_files]
    print('postprocessing: input = ')
    if len(input_root_files) == 0:
        print('postprocessing: No files to concatenate; exiting')
        return
        
    for input_file in input_root_files:
        command = '{} {}'.format(command, input_file)
        print(input_file)

    print('postprocessing: Starting hadd')
    subprocess.call(command, shell=True)
    print('postprocessing: hadd done\n')

def gain_var(input_folder,hist_substr,output=None,force=None):
    file_list = listdir(input_folder)
    fobj_list = []
    hist_list = []
    range_y =[0,0]
    can =  ROOT.TCanvas("gain","gain",600,400)
    for gain_file in file_list:
        fobj_list.append(ROOT.TFile.Open(input_folder+"/"+gain_file))
        f = fobj_list[-1]
        hist_names = {keys.GetName() for keys in f.GetListOfKeys()}
        hList = [hist for hist in hist_names if hist.find(hist_substr) != -1]
        h = f.Get(hList[0])
        hist_list.append(h)

        hMin = h.GetMinimum()
        hMax = h.GetMaximum()
        if hMin < range_y[0]: range_y[0] = hMin
        if hMax > range_y[1]: range_y[1] = hMax

    nFiles = len(hist_list)
    #List of (integral, filename, TH1) over all files
    hist_ints = [[hist_list[i].Integral(),file_list[i],hist_list[i]] for i in range(nFiles)]
    hist_ints.sort(reverse=True)

    ROOT.gStyle.SetOptStat(0)
    for i in range(nFiles):
        m = match(r"rid0+(?P<run_id>\d+_\d+)_gain.root", hist_ints[i][1])
        if  m is not None:
            hist_ints[i][1] = m.group("run_id")
        else:
            hist_ints[i][1] = hist_ints[i][1][:-5]


    hist_list[0].Draw()
    hist_ints[0][2].SetLineColor(2)
    hist_list[0].SetAxisRange(range_y[0] - 0.02*abs(range_y[1]),range_y[1]+0.02*abs(range_y[1]),"Y")
    for h in hist_list[1:]:
        h.Draw("same")

    int_box = ROOT.TPaveText(0.7, 0.6, 0.90, 0.90, "BRNDC")
    int_box.SetTextColor(1)
    int_box.SetFillColor(0)
    int_box.SetTextSize(0.030)
    int_box.SetBorderSize(1)
    for i in range(nFiles):
        integral_tuple = hist_ints[i]
        legend_text = integral_tuple[1]+": {:.4e}".format(integral_tuple[0])
        int_box.AddText(legend_text)
        if i>5:
            break

    int_box.Draw()
    can.SaveAs(join(output,"gain_concat.pdf"))
    for f in fobj_list:
        f.Close()


# not used by the job submission but useful for local testing
if __name__ == "__main__":

    print('\n P8 DIRAC postprocessing script\n')
    p = argparse.ArgumentParser(description='''
        Postprocessing script
    ''')
    p.add_argument('-o', '--output',
                   help='Output filename/directory',
                   default='.',
                   type=str)
    p.add_argument('-f', '--force',
                                   help='Force operation',
                                   action='store_true',
                                   default=False)
    subparsers = p.add_subparsers(
        dest='subparser', help='Postprocessing action')
    
    parser_concat_rid = subparsers.add_parser(
        'concat_root_rid', help='Concat ROOT files by giving a run ID')
    parser_concat_rid.add_argument('-r', '--rid',
                                   type=str,
                                   help='Select rid: if given as "7190-7200", will generate concat files for the range of given runs',
                                   required=True)
    parser_concat_rid.add_argument('-i', '--input_folder',
                                   type=str,
                                   help='Input Folder',
                                   default=".")
    parser_concat_rid.add_argument('-k', '--katydid',
                                   type=str,
                                   help='Katydid version',
                                   required=True)

    parser_concat = subparsers.add_parser(
        'concat_root', help='Concat ROOT files by giving a list of files')
    parser_concat.add_argument('-i', '--input_root_files',
                               nargs='+',
                               type=str,
                               help='List of/or string of input file(s)',
                               default=".")
    parser_plots = subparsers.add_parser(
        'data_quality', help='data quality help')
    parser_plots.add_argument('-i', '--input_file',
                              nargs='+',
                              help='List of/or string of input file(s)',
                              type=str,
                              default=".")
    parser_plots.add_argument('-t', '--tree_name',
                              help='Tree name containing the relevant informations',
                              type=str,
                              default='multiTrackEvents')
    parser_plots.add_argument('--notify_slack', nargs='?',
                              help='Send completion message to #dirac_notices (only do if sure)',
                              const=True,
                              default=False)
    parser_plots = subparsers.add_parser(
        'gain_var', help='make combined gain variation plot')
    parser_plots.add_argument('-i', '--input_folder',
                              help='folder containing gain vars',
                              type=str,
                              default='')
    parser_plots.add_argument('-s', '--hist_substr',
                              help='substring of histogram for plot',
                              type=str,
                              default='histGVVar')
    parser_plots = subparsers.add_parser(
        'trigger_mask', help='plot trigger masks')
    parser_plots.add_argument('-i', '--input_file',
                              nargs='+',
                              help='List of/or string of input file(s)',
                              type=str,
                              default=".")

    kwargs = vars(p.parse_args())
    globals()[kwargs.pop('subparser')](**kwargs)
    print('postprocessing: Done... for now!')
    sys.exit(0)
